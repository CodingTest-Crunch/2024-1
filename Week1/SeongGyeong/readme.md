### 2024.04.01

1. 백준 9095번

   - dp 유형 기본 같은 문제
   - 오랜만에 dp를 풀어보게 되어서 기억을 되살릴 겸 풀어봤습니다.
   - 처음에는 1 1 에 2를 붙인 경우 112,211, 121을 다 고려해야하는지 헷갈렸는데 그냥 작은 수에 대해서 노가다로 세어보니까 고려하지 않아도 된다는 걸 깨닫고 빠르게 점화식을 세웠습니다.

2. 백준 2805

   - 이분 탐색 유형 기본 같은 문제
   - 다른 건 다 괜찮았는데 "적어도 M 이상"이라는 조건을 잘 해석하지 못하고 M과 rest의 길이가 같으면 그냥 return 시켰는데 톱날 위치의 최댓값을 구하는 것이고, 같은 M이어도 여러 톱날의 길이가 있을 수 있다는 것을 고려하지 못했다는 것을 알았습니다.
   - 그리고 마지막에 mid를 계속 출력하다가 애를 먹었는데 위 상황을 고려해서 코드를 다시 짜게 되면 결국 항상 start = end + 1의 상태로 return 이 되고, mid는 예전 값에 머물러 있기 때문에 end를 출력해야한다는 것을 알았습니다.
   - 그리고 `if rest > M : break` 이 부분 가지치기를 하지 않으면 어이없게도 파이썬에서 시간 초과가 나서, 가지치기 하는 습관을 들여야겠다고 생각했어요.

---

### 2024.04.02

3. 백준 2667번

   - BFS 유형
   - 처음에 덩어리 수를 세는 게 어려웠는데, 인풋 수도 작으니까 이중 반복문 돌려서 하나씩 체크하면 되겠다! 떠올리고 바로 정답!

   ```
   if graph[ny][nx] == 1:
      ans += 1
      q.append((nx,ny))
      visited[ny][nx] = 1
   ```

   이 부분도 조금 헷갈렸는데

   ```
   if graph[ny][nx] == 1:
      ans += 1
   q.append((nx,ny))
   visited[ny][nx] = 1
   ```

   이렇게 세다가 결과가 이상하게 나와서 잠시 헤맸다.
   생각해보면 1이 적힌 애들만 세야하기 때문에 0인 부분은 다른 덩어리의 시작점이 될 수 있어서 세면 안된다!

   - 인풋 입력을 더 간단하게 받는 방법이 있다!

   ```
   # for i in range(N) :
   <!-- 내가 쓴 코드 -->
   #     num = sys.stdin.readline().strip()
   #     arr = []
   #     for i in range(len(num)):
   #         arr.append(int(num[i]))
   #     graph.append(arr)

   for i in range(N) :
      graph.append(list(map(int, sys.stdin.readline().strip())))
   ```

4. 백준 9095 (복습)
   - 어제 푼 9095번을 다시 풀어보면서 복습했어요

---
