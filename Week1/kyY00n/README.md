# 4월 1주차 알고리즘

4/1 ~ 4/7 까지 푼 문제들입니다. 

## 1. 나머지 합

[문제 보기](https://www.acmicpc.net/problem/10986)

### 문제 분석

- input
  - 1 <= N <= 10^6: 수열의 크기
  - 2 <= M <= 10^3: divisor
  - 0 <= A_i <= 10^9: 수열의 요소
- 시간 제한: 1초

### 핵심 아이디어

- 수열의 크기는 1M 이지만, 부분 수열을 완전탐색으로 찾기 위해서는 100M의 계산을 훌쩍 넘을 것이다. -> 부분합을 이용한다.

- 우리가 궁금한 건, 부분합 자체가 아니라 부분합을 M으로 나눈 값이다.
  - 따라서, prefixSum 배열을 두고 계속해서 M으로 나눠서 저장한다.
  - prefixSum[i] = (prefix[i - 1] + (A[i] % M)) % M
    이 아이디어를 이용한다.
- 1에서 부터의 부분합의 나머지가 같은 i와 j (i <= j)의 부분합 p[i, j]는 prefixSum[j] - prefixSum[i] 이므로, prefixSum[j] 와 prefixSum[i]가 동일한 i와 j를 찾으면 된다. -> 갯수를 미리 세고, 조합(2개를 뽑으면 되니 $$nC2$$ 공식)을 사용한다.

### 내가 계속해서 틀린 이유

이 문제의 아이디어까지 확인하고 확신에 찬 상태로 여러번 제출하면서도 번번이 틀렸다.
알고보니 그 이유는

`count` 배열과 answer 변수의 **자료형** 때문이었다.

이 둘은 부분배열의 가짓수를 저장하는 용도의 변수들이기 때문에, int 범위를 벗어날 수도 있다.

한번 볼까?

언제 count 요소와 answer 의 값이 가장 클까?

바로 수열의 크기가 최대 크기인 10^6이고, A_i가 모두 동일한 때 count 가 가장 크다.
그리고 answer까지 가장 커지려면 A_i가 모두 M의 배수여야한다. (`A_i % M == 0` 인 경우 요소 갯수 만큼 answer가 늘어나기 때문에)

이때, prefixSum 배열은 이런 형태일 것이다.

```java
{ 0, 0, 0, ....., 0 }
```

그렇다면 `count` 배열은 어떻게 될까?

`count[0] = (10 ^ 6) * (10 ^ 6 - 1) / 2 = 499,999,500,000`이 된다.
그러면 int를 벗어난다.

`answer` 는 어떻게 될까?

`answer = (10^6) + (10 ^ 6) * (10 ^ 6 - 1) / 2 = 500,000,500,000` 가 된다. 마찬가지로 int를 벗어난다.

따라서 두 자료형 모두 long 을 사용해주는 것을 반드시 짚고 넘어가자.
