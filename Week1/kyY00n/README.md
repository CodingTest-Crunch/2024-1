# 4월 1주차 알고리즘

4/1 ~ 4/7 까지 푼 문제들입니다. 

## 1. 나머지 합

[문제 보기](https://www.acmicpc.net/problem/10986)

### 문제 분석

- input
  - 1 <= N <= 10^6: 수열의 크기
  - 2 <= M <= 10^3: divisor
  - 0 <= A_i <= 10^9: 수열의 요소
- 시간 제한: 1초

### 핵심 아이디어

- 수열의 크기는 1M 이지만, 부분 수열을 완전탐색으로 찾기 위해서는 100M의 계산을 훌쩍 넘을 것이다. -> 부분합을 이용한다.

- 우리가 궁금한 건, 부분합 자체가 아니라 부분합을 M으로 나눈 값이다.
  - 따라서, prefixSum 배열을 두고 계속해서 M으로 나눠서 저장한다.
  - prefixSum[i] = (prefix[i - 1] + (A[i] % M)) % M
    이 아이디어를 이용한다.
- 1에서 부터의 부분합의 나머지가 같은 i와 j (i <= j)의 부분합 p[i, j]는 prefixSum[j] - prefixSum[i] 이므로, prefixSum[j] 와 prefixSum[i]가 동일한 i와 j를 찾으면 된다. -> 갯수를 미리 세고, 조합(2개를 뽑으면 되니 $$nC2$$ 공식)을 사용한다.

### 내가 계속해서 틀린 이유

이 문제의 아이디어까지 확인하고 확신에 찬 상태로 여러번 제출하면서도 번번이 틀렸다.
알고보니 그 이유는

`count` 배열과 answer 변수의 **자료형** 때문이었다.

이 둘은 부분배열의 가짓수를 저장하는 용도의 변수들이기 때문에, int 범위를 벗어날 수도 있다.

한번 볼까?

언제 count 요소와 answer 의 값이 가장 클까?

바로 수열의 크기가 최대 크기인 10^6이고, A_i가 모두 동일한 때 count 가 가장 크다.
그리고 answer까지 가장 커지려면 A_i가 모두 M의 배수여야한다. (`A_i % M == 0` 인 경우 요소 갯수 만큼 answer가 늘어나기 때문에)

이때, prefixSum 배열은 이런 형태일 것이다.

```java
{ 0, 0, 0, ....., 0 }
```

그렇다면 `count` 배열은 어떻게 될까?

`count[0] = (10 ^ 6) * (10 ^ 6 - 1) / 2 = 499,999,500,000`이 된다.
그러면 int를 벗어난다.

`answer` 는 어떻게 될까?

`answer = (10^6) + (10 ^ 6) * (10 ^ 6 - 1) / 2 = 500,000,500,000` 가 된다. 마찬가지로 int를 벗어난다.

따라서 두 자료형 모두 long 을 사용해주는 것을 반드시 짚고 넘어가자.

## 2. 수들의 합 5

[문제보기](https://www.acmicpc.net/problem/2018)

### 문제 분석

- input
  - N(1 ≤ N ≤ 10,000,000)
- 시간 제한: 2초

### 핵심 아이디어

- 포인터 두 개를 사용한다. (`left`, `right`)
- 합을 구할 때, 매번 전부 다시 계산하지 않고 이동한 포인터에 대해서만 값을 반영해준다.

### 헷갈렸던 것

헷갈렸던 것이, 전부 while 블록과 관련있었다.

```java
while (left <= right) {
    if (sum == N) {
        answer++;
    }
    if (sum < N) {
        right++;
        sum += right;
    } else {
        sum -= left;
        left++;
    }
}
```

1. while 조건
    : do while을 사용하고, 조건을 `left < right` 로 했었다.
    그리고, `answer = 1`로 초기화 했는데, 이 로직에는 반례가 있었다.
    만약 N 이 1일 경우, 일단 do while 블록이 한 번 실행되기 때문에 answer가 1이 되어버리는 것이었다.
2. `right`과 `left` 갱신 순서
   : 구간 자체가 오른쪽으로 이동(left, right 이 1에서 시작)하기 때문에 두 포인터의 이동을 반영할 때 순서를 달리해야했다.
    - `right` 포인터가 이동하면 새로운 숫자를 더해야한다. 즉, 새로운 숫자를 `sum`에 더하기 위해 포인터를 먼저 이동하고 `sum`에 `right` 을 더해주어야 한다.
    - `left` 포인터가 이동하면 기존의 숫자를 빼야한다. 즉, 기존의 숫자를 `sum`에서 빼기 위해, `sum` 에서 `left`를 뺀 뒤에 포인터를 오른쪽으로 이동시켜야한다.