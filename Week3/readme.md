### 240429

1. 백준 11403 (실버 1, 플로이드-워셜)

   - 플로이드 워셜이라는 알고리즘이 있는지 아예 몰랐아요 그래서 그냥 구글링해서 코드 보고 공부했습니다.

   ### 플로이드 워셜

   - 다익스트라가 하나의 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘이었다면, 플로이드-워셜은 모든 노드 간 최단 경로를 구하는 알고리즘
   - 모든 노드 간의 최단 거리를 구해야하기 때문에 2차원 인접 행렬을 구성한다.
   - 각 라운드마다 각 경로에서 새로운 중간 노드로 활용할 수 있는 노드를 선택하고 더 짧은 길이를 선택하여 줄이는 과정을 반복한다

   ```python
   for k in range(1,n) :
       for i in range(1,n) :
           for j in range(1,n) :
               dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
   ```

---

### 240430

2. 백준 11404 (골드 4, 플로이드-워셜)

   - 11403번을 풀면서 플로이드-워셜에 대해 배웠기 때문에 바로 연달아서 풀이했어요
   - 플로이드-워셜의 코드만 제대로 알면 풀이 방법을 찾는데는 어렵지 않았지만, 도달하지 않은 부분에 대해 처리를 해주는 것이 어려웠어요.

   ```
   # 최단 거리를 구하는 거니까 일단 초기화는 엄청 큰 값으로!
   INF = int(1e9)
   ```

---

### 240501

3. 백준 1107 (골드 5, 브루트포스)

   - 브루트포스 문제인데 뭔가 이렇게 완전 탐색하는 문제가 시간초과가 걸릴까봐 쉽사리 이 문제 풀이 방법을 생각해내지 못했어요
   - 시간 제한을 보고 시간이 넉넉하면 브루트포스도 고려해봐야한다는 걸 배웠어요
   - 만약에 N이 500000이면 100에서 +만 눌러서 오는 것보다 600000에서 오는 게 더 가까울 수 있는데, 이 부분을 고려한 부분을 짜는게 어려웠어요.

   ````
   # 자릿수만큼 숫자 버튼 누르는 횟수 + +/- 횟수
   # 만약에 N이 500000이면 100에서 +만 눌러서 오는 것보다 600000에서 오는 게 더 가까울 수 있다
   # 따라서 500000을 100부터 ++만으로 오는게 499900이니까
   # 그것보다 적게 걸리는 범위 내에서 500000보다 큰 수까지 돌려줘야한다
   for num in range(999900) :
       for N in str(num) :
           if N in broken :
               break
       else :
           ans = min(ans, len(str(num)) + abs(num-target))
       ```
   ````

---

### 240502

4. 백준 14500 (골드 4, 구현/dfs)

   - 문제는 이해했고, 그래프 탐색을 이용해야겠다는 생각은 했는데 그 이상 생각이 발전하지 못했어요
   - 한붓그리기로 가능한 모양의 경우에는 dfs로 체크를 해주면 되는데, 한붓그리기가 되지 않고 ㅓ,ㅗ,ㅏ,ㅜ 같은 모양은 따로 체크를 해줬어야 하는데 여기가 좀 까다로웠어요

   ```python
    def exception(y,x):
    global maxValue
    arr = []
    # 일단 네 방향 모두 계산을 한다
    for i in range(4) :
        nx,ny = x + dx[i], y+dy[i]
        if 0<=nx<M and 0<=ny<N :
            arr.append(tetris[ny][nx])
    # 네 방향 모두 범위 안에 들어오면
    if len(arr) == 4 :
        # 오름차순으로 정렬해서
        arr.sort(reverse=True)
        # 제일 작은 수 삭제
        # remove 쓰면 - remove(3) : 배열에서 가장 첫번째로 나오는 3 삭제
        arr.pop(0)
        maxValue = max(maxValue, sum(arr)+tetris[y][x])
    elif len(arr) == 3 :
        maxValue = max(maxValue, sum(arr)+tetris[y][x])
    return
   ```

   - dfs도 문제를 푼지 오래되고 bfs 위주로 풀어서 까먹었었는데 이 문제로 연습했습니다 :D
