# [0408] 올바른 괄호 - 스택 활용한 풀이

## 문제 설명

'(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false

## 기억할 부분

Stack<Character> st = new Stack<>();

# [0409] 가장 큰 수 - 정렬 활용한 풀이

## 문제 설명

[3, 30, 34, 5, 9] "9534330"

## 기억할 부분

Arrays.sort(arr, (a, b) -> (b + a).compareTo(a + b));

두개의 문자열을 합친 결과를 사전 순서로 비교한다.
만약 합친 결과인 (b + a) 가 (a + b) 보다 순서상 크다면 양수 반환
(b + a)가 (a + b)와 사전 순서상 동일하다면 0을 반환
(b + a)가 (a + b)보다 사전 순서상으로 작다면 음수를 반환
[3, 30, 34, 5, 9] 를 9534330 으로 정렬

# [0410] 프로세스 - 스택 활용한 풀이

## 문제 설명

[2, 1, 3, 2] -> [3,2,2,1]
idx가 2일때 답은 3은 우선순위 큐 정렬 된 배열에서 몇번째로 실행되는가? 1번째

## 기억할 부분

PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
우선순위 큐를 생성할때 큰 값이 더 높은 우선순위를 가짐 : 내림차순으로 정렬됨

# [0411] 타겟 넘버 - dfs 활용한 풀이

## 문제 설명

[1, 1, 1, 1, 1] target 이 3이 되도록 하는 경우의 수 구하기 : 5

## 기억할 부분

dfs 사용하기

# [0412] 트리와 쿼리 - dfs 활용한 풀이

## 문제 설명

각 정점에서 쿼리 구하기

## 기억할 부분

순서중요
sum[root] += sum[child];

# [0413] 트리의 부모 찾기 - dfs 활용한 풀이

## 문제 설명

1-6-3-5
1-4-2
-7
에서 각 노드의 부모 노드 구하기

## 기억할 부분

List<Integer> tree[] 배열을 사용해서 인접 리스트로 풀기

# [0414] 순열 사이클 - dfs 활용한 풀이

## 문제 설명

순열 그래프 (3, 2, 7, 8, 1, 4, 5, 6) 에는 총 3개의 사이클
1->3 2->2 3->7 4->8 5->1 6->4 7->5 8->6

## 기억할 부분

find함수에서 check[child[node]] = true; 이렇게 쓰지 말기
