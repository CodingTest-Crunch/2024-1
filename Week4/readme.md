### 240507

1. 백준 2667 (실버 1, dfs)

   - 최소 경로를 구하는 문제는 아니라서 사실 bfs, dfs 모두 가능한 문제입니다
     - bfs로 너비 우선으로 탐색을 하든, dfs로 깊이 우선 탐색을 하든 한 덩어리 내의 모든 노드를 순회하니까!
   - bfs 풀이만 많이 하다가 dfs를 까먹은 것 같아서 dfs 방법으로 풀이해줬어요

   ```python
   def dfs(y, x, graph) :
   global cnt

   for i in range(4) :
       nx, ny = x + dx[i], y + dy[i]
       if 0<=nx<N and 0<=ny<N and not visited[ny][nx] and graph[ny][nx] == 1 :
           cnt += 1
           visited[ny][nx] = True
           dfs(ny, nx, graph)
   ```

---

### 240508

2. 백준 7576 (골드 5, bfs)

   - 이 문제를 dfs로 풀면 된다고 생각한 이유 / 풀면 안되는 이유

     - bfs는 붙어있는 노드부터 순회를 하니까 -> 근데 오히려 이 이유로 bfs를 사용해야했던 것! bfs를 쓰면 단계별로 1인 노드를 감싸고 있는 층부터 순서대로 순회할 수 있다.
     - 네 방향으로 중구난방으로 순회를 하는 게 내 머릿 속에 있었는데,,, 왜 그랬을까,,,
     - 오히려 dfs를 쓰면 한 방향으로 쭈욱 가기 때문에 층층이 순회할 수 없어서 dfs를 쓰면 안된다

   - 처음에 1인 노드의 위치를 queue에 넣을 생각을 못해서 1로 쭉 토마토를 익게 만들었는데 그리고 나서 한 3층 떨어져서 또 토마토가 어떡하지? 생각했는데

   ```
   graph[ny][nx] = graph[y][x] + 1
   ```

   이렇게 그 전 층의 노드에 +1 하는 방향으로 count를 한 후 최종적으로 토마토 창고 전체의 max 값을 취해주면 되는 거였다!
